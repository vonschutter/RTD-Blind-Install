#!/bin/bash
#::				S I M P L E     S Y S T E M   S U P P O R T    T O O L
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#:: Author(s):   	SLS, KLS, NB.  Buffalo Center, IA & Avarua, Cook Islands
    RTD_Version=1.09-Beta
#::
#::
#::	Purpose: To simplify support tasks
#::		  - Display system information
#::		  - Update system software
#:: 		  - Bakup virtual machines
#::               - Cleanup/Report on PPA's
#::               - Show systems physical location
#::		  - Check if a password you intend to use is for sale on the Darknet
#::
#::     Usage: run the script "bash /path/to/rtd" or if installed in the $PATH; by rtd simply type "rtd" in a terminal.
#::
#::     This script is shared in the hopes that
#::     someone will find it usefull.
#::
#::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
#	NOTE:	This terminal program is written to be readable and documented to a very high degree. The reason is that
#		these apps are seldom changed and when they are, it is usefull to be able to understand why and how
#		things were built. Obviously, this becomes a useful learning tool as well; for all people that want to
#		learn how to write admin scripts. It is a good and necessary practice to document extensively and follow
#		patterns when building your own apps and config scripts. Failing to do so will result in a costly mess
#		for any organization after some years and people turnover.
#
#		As a general rule, we prefer using functions extensively because this makes it easier to manage the script
#		and facilitates several users working on the same scripts over time.
#
#
#	RTD admin scrips are placed in /opt/rtd/scripts. Optionally scripts may use the common
#	functions in _rtd_functions and _rtd_recipies:
#
#	  _rtd_functions -- contain usefull admin functions for scripts, such as "how to install software" on different systems.
#	  _rtd_recipies  -- contain software installation and configuration "recipies".
#
#	Scripts may also be stand-alone if there is a reason for this. This script is written to function independently
#	so that it is easy to copy to many server systems, or just to use once on a remote system. This is accomplished by
#	including all functions and dependency checking in this script; as well as avoidnig relying on external files like
#	*.diff files. As a consequence of the portability benefit this script becomes rather large and time consuming to navigate.
#
#	Taxonomy of this script: we prioritize the use of functions over monolithic script writing, and proper indentation
#	to make the script more readable. Each function shall also be documented to the point of the obvious.
#	Suggested function structure per google guidelines:
#
#	function_descriptive_name () {
#		# Documentation and comments...
#		...code...
#	}
#
#	We also like to log all activity, and to echo status output to the screen in a frienly way. To accomplish this,
#	the table below may be used as appropriate:
#
#				OUTPUT REDIRECTION TABLE
#
#		  || visible in terminal ||   visible in file   || existing
#	  Syntax  ||  StdOut  |  StdErr  ||  StdOut  |  StdErr  ||   file
#	==========++==========+==========++==========+==========++===========
#	    >     ||    no    |   yes    ||   yes    |    no    || overwrite
#	    >>    ||    no    |   yes    ||   yes    |    no    ||  append
#	          ||          |          ||          |          ||
#	   2>     ||   yes    |    no    ||    no    |   yes    || overwrite
#	   2>>    ||   yes    |    no    ||    no    |   yes    ||  append
#	          ||          |          ||          |          ||
#	   &>     ||    no    |    no    ||   yes    |   yes    || overwrite
#	   &>>    ||    no    |    no    ||   yes    |   yes    ||  append
#	          ||          |          ||          |          ||
#	 | tee    ||   yes    |   yes    ||   yes    |    no    || overwrite
#	 | tee -a ||   yes    |   yes    ||   yes    |    no    ||  append
#	          ||          |          ||          |          ||
#	 n.e. (*) ||   yes    |   yes    ||    no    |   yes    || overwrite
#	 n.e. (*) ||   yes    |   yes    ||    no    |   yes    ||  append
#	          ||          |          ||          |          ||
#	|& tee    ||   yes    |   yes    ||   yes    |   yes    || overwrite
#	|& tee -a ||   yes    |   yes    ||   yes    |   yes    ||  append
#
#	Our scripts are also structured in to three major sections: "settings", "functions", and "execute".
#	Settings, contain configurable options for the script. Functions, contain all functions. Execute,
#	contains all the actual logic and control of the script.
#
#
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::





#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::            Script Settings               ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
# You may comment out or edit items as you deem necessary.
# Some formatting options for cli graphic display.
BRANDING="RunTime Data : Simple Server Support Tool"
BRANDING_ORG="RTD"
DIALOG_CANCEL=1
DIALOG_ESC=255
HEIGHT=20
WIDTH=80
LIST_HEIGHT=12

# Set location to backup virtual machines to. This location must have addequate space
# to store several copies of the virtual machine disks. This may be a network share or
# an external storage or san mount point. If you do non need to backup VMs you can set
# this to blank or ignore it. If you do not have QEMU/KVM installed selecting this
# option to back up Virtual Machines in the menu will do nothing.
VM_BACKUP_TARGET="/mnt/vmdsk/VM_BACKUP"

# Terminal Color Setup definitions. These settings allow the simlified use of
# text colors in the teminal. You may want to echo RED for error or GREEN for OK.
YELLOW="\033[1;33m"
RED="\033[1;31m"
ENDCOLOR="\033[0m"
GREEN="\033[1;32m"
BLUE="\033[1;34m"

# Set the background color of the tool. The appearance of the manu system may
# look different on different systems depending on their default settings.
# Here we define the bacground color for consistency. You may slect a front end to 
# the rtd tool below. Valid choices are:dialog, whiptail.
RTD_GUI=whiptail
export NEWT_COLORS='root=,gray '


# Details for the ISO image creator. To change from one Ubuntu release to another you
# may change the "RELEASE" option. If you wold like to use the ISO maker to build a custom
# Debian installer you may change the "SOURCE_ISO_URL" option to poit to the Debian location.
# Finally, should you desire using your own preseed template (answers to the install questions)
# you should change the "PRESEED_TEMPLATE" option to point to the location of you own template.
RELEASE=eoan
TARGET_ISO_FILE_NAME=
SOURCE_ISO_URL=
SSH_PUBLIC_KEY_FILE=
PUT_ISO_FILE_HERE_WHEN_DONE=
PUT_QCOW_FILE_HERE_WHEN_DONE=
VOLUME_TITLE=
PRESEED_TEMPLATE=

# Set location to where to log information:
# in the system log directory in a file named the same as this script.
LOGFILE="/var/log/${0##*/}.log"
DBG=#







#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::            Tool Executive Functions      ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
# Below please find the executive functions of this script. These are the functions
# that actually do the work requested.
#
#

rtd_oem_pause() {
	read -p "Press [ENTER] To continue ... "

}

ensure_admin () {
        # Function to ensure administrative privileges such that system wide settings
        # or configuration may be done. This function will make the script call itself
        # with sudo if the user ID is not 0 e.g. root.
        [ "$UID" -eq 0 ] || echo -e $YELLOW "The $BLUE $BRANDING $YELLOW needs administrative access..." $ENDCOLOR
        [ "$UID" -eq 0 ] || exec sudo bash "$0" "$@"
    }



check_if_password_p0wned () {
	pass_str=$($RTD_GUI --passwordbox "Please enter your intended password to validate your new password against P0wned DB" 8 78 --title "" 3>&1 1>&2 2>&3)
	result=$(
		sha1=$(echo -n $pass_str | tr -d '\n' | sha1sum); echo "Hash prefix: ${sha1:0:5}"; echo "Hash suffix: ${sha1:5:35}";
		query_result=$(curl https://api.pwnedpasswords.com/range/${sha1:0:5} 2>/dev/null | grep $(echo ${sha1:5:35} | tr '[:lower:]' '[:upper:]'));
		printf "Your password appeared %d times for sale in the Darknet per the P0wned online database...." "${query_result#*:}" 2>/dev/null ;
		unset pass_str ;
		)
	display_result "Password P0wned Status"
}



convert_vdi_2_qcow2 () {
	# Function to import a VirtualBox image to KVM. qcow is a file format for disk
	# image files used by QEMU, a hosted virtual machine monitor.[1] It stands for
	# "QEMU Copy On Write" and uses a disk storage optimization strategy that delays
	# allocation of storage until it is actually needed. This is the required format for
	# qemu/KVM virtual machines. VDI: This format is the VirtualBox-specific VirtualBox Disk Image
	qemu-img convert -f vdi -O qcow2 $VDI $QCOW2
}



change_disk_pass () {
	# Function to change the passphrase fo an encrypted storage device.
	# It will offer to change the first encrypted volume found by blockid.
	# It is unclear how this will work if there are multiple encrypted volumes found.
	clear
	echo Changing the disk encryption password for your hard drive:
	cryptsetup luksChangeKey $(blkid | grep crypto_LUKS|  cut -d : -f 1)
	read -p "Press  [ ENTER ] to continue:"

}



rtd_oem_setup_brand_splash_screen() {
	# Function to brand the installer splash screen for the customized installer
	# downloaded from a ginve vendor. This function expects a few simple peices of information: 
	# parameter 1: full path to image file to be branded. 
	# parameter 2: quoted text to be incerted. 
	image_file_to_brand=$1
	text_to_brand_with=$2

	# Ensure that imagemagik is installed so images can be manipulated.  
	check_dependencies imagemagick
	
	# Default locations and splash screens based on debian and ubuntu, meaning this function will assume you are 
	# making an ubuntu or debian boot iso as this is generally what this function was written to do. However these values
	# can be overridden by passing the 2 parameters to this script. 
	: "${image_file_to_brand:="$(
		if [ -f $TMP_DISC_DIR/splash.png ]; then
			echo "$TMP_DISC_DIR/splash.png"
		elif [ -f $TMP_DISC_DIR/isolinux/splash.png ]; then 
			echo "$TMP_DISC_DIR/isolinux/splash.png"
		fi )" }"
	
	: "${text_to_brand_with:="$( echo " RunTime Data OEM Install: $PREFERENCE" )" }"

	echo -e $GREEN "found: $image_file_to_brand"  $ENDCOLOR
	echo -e $GREEN "branding with: $text_to_brand_with " $ENDCOLOR

	if [ -f $image_file_to_brand ]; then
		convert $image_file_to_brand -gravity north -stroke '#000C' -strokewidth 3 -annotate 0 "$text_to_brand_with" -stroke none -strokewidth 3 -fill white -annotate 0 " $text_to_brand_with "  edit-out.png
		rm $image_file_to_brand
		mv edit-out.png $image_file_to_brand
		#echo -e $RED "Image [ $image_file_to_brand ] NOT branded!  " $ENDCOLOR
		
	fi
}





prepare_environment_for_iso_creation () 
{
	# Function to check that all dependencies are available for manipulating the
	# net install ISO from Ubuntu. Subsequently, the temporary file locations
	# are setup and templates are downloaded.

	#Include the path to where the isofile will be put...
	: "${TARGET_ISO="$PUT_ISO_FILE_HERE_WHEN_DONE/$TARGET_ISO_FILE_NAME"}"
	# Ensure that all needed software, outside of the most rudimantary,
	# is available to us... If not, the script should exit.
	: "${_DEPENDENCIES="dos2unix cpio gzip genisoimage whois pwgen wget fakeroot xorriso"}"
	#set -e
	for i in $_DEPENDENCIES
	do
		check_dependencies $i
	done
	
	# Find full paths for the binaries needed since if they are recently
	# added, they may not be found in the current $PATH. These statements will be evaluated
	# when the variables are referenced not here because of the ":". FYI...
	: "${BIN_7Z:=$(type -P 7z)}"
	: "${BIN_XORRISO:=$(type -P xorriso)}"
	: "${BIN_CPIO:=$(type -P gnucpio || type -P cpio)}"
	: "${ISOHDPFX_BIN:=$(locate isohdpfx.bin  | head -n 1)}"
	: "${PUT_ISO_FILE_HERE_WHEN_DONE:="/home/$SUDO_USER/Virtual-DVDs"}"
	: "${PUT_QCOW_FILE_HERE_WHEN_DONE:="/home/$SUDO_USER/Virtual-HDs"}"
	: "${VOLUME_TITLE:="RTD Auto Installer"}"
	: "${SSH_PUBLIC_KEY_FILE:="/home/$SUDO_USER/.ssh/id_rsa.pub"}"
	: "${PERMANENT_DOWNLOAD_DIR:="/home/$SUDO_USER/Virtual-DVDs/Downloaded"}"
	# Find the location of the public key on this machine...
	# This should be updated to create a key if not there...
	if [ ! -f "$SSH_PUBLIC_KEY_FILE" ];
	then
		echo "Error: public SSH key $SSH_PUBLIC_KEY_FILE not found!"
		echo "You will need to setup automatic login using ssh manually each time oyu build a server with this media."
		read -p "Press [Enter] to continue..."
		# exit 1
	fi

	# Setup the required folder structure...
	CURRENT_DIR="`pwd`"
	SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
	TMP_DOWNLOAD_DIR=$(mktemp -d )
	TMP_DISC_DIR=$(mktemp -d )
	TMP_INITRD_DIR=$(mktemp -d )

	for i in $PUT_QCOW_FILE_HERE_WHEN_DONE\
		$PUT_ISO_FILE_HERE_WHEN_DONE\
		$PERMANENT_DOWNLOAD_DIR
	do
		mkdir -p -m 770 "$i" && chown $SUDO_USER:$SUDO_USER "$i"
	done
}


rtd_oem_ubuntu_auto_install_iso_builder()
{
	prepare_environment_for_iso_creation
	CONFIG=$1
	all=($(wget -O- releases.ubuntu.com -q | perl -ne '/Ubuntu (\d+.\d+)/ && print "$1\n"' | sort -Vu))
	v=$($RTD_GUI --inputbox "Please pick an available ubuntu version by entering it below. Versions to choose from: ${all[*]} If you are not sure just let me choose for you... I will allways choose the latest available version. " 8 78 "${all[-1]}" --title "Select Release Version of Ubuntu" 3>&1 1>&2 2>&3)
	[ "$v" ] || v=${all[-1]}
	iso_url=$(rtd_oem_find_ubuntu_release $v)
	iso_base=$(basename $iso_url)
	base=$(basename $iso_url .iso)
	iso=$(find "$PERMANENT_DOWNLOAD_DIR" -name "$iso_base")
	if [ ! -e "$iso" ]; then
		wget -nc $iso_url -P "$PERMANENT_DOWNLOAD_DIR" || return
		iso="$PERMANENT_DOWNLOAD_DIR/$iso_base"
	fi

	mnt="${TMP_DISC_DIR:=$(mktemp -d )}"
	mount $iso $mnt -o user,ro
	cat $mnt/.disk/*info
	read a b c < $mnt/.disk/*info
	auto=$BRANDING_ORG-$CONFIG-${base}-auto-install
	if [ ! -e $auto ]; then
		cp -a $mnt $auto
		chmod -R +w $auto
	fi
	sudo umount $mnt
	kickstart-cfg $auto

	### -- Remember to make this optional --- ###
	cat >> $auto/ks.cfg <<-EOF
	%post --nochroot
	mkdir -p /target/home/$SUDO_USER/.ssh/
	echo $(cat  ${SSH_PUBLIC_KEY_FILE ) >> /target/home/$SUDO_USER/.ssh/authorized_keys
	chown -R $SUDO_USER /target/home/$SUDO_USER/.ssh/
	setv() { sed -i "s/^\(\$2=\).*/\1\$3/" \$1; }
	cd /target/etc/default
	setv grub GRUB_CMDLINE_LINUX_DEFAULT ""
	cd -
	chroot /target update-grub
	%end
	EOF

#	rtd_oem_setup_brand_splash_screen


	if [[ -f $PUT_ISO_FILE_HERE_WHEN_DONE/$auto.iso ]]; then 
		rm $PUT_ISO_FILE_HERE_WHEN_DONE/$auto.iso 
	fi

	$BIN_XORRISO -as mkisofs -isohybrid-mbr "$ISOHDPFX_BIN" \
		-c isolinux/boot.cat -b isolinux/isolinux.bin \
		-no-emul-boot -boot-load-size 4 -boot-info-table \
		-eltorito-alt-boot -e boot/grub/efi.img -no-emul-boot \
		-isohybrid-gpt-basdat -o "$PUT_ISO_FILE_HERE_WHEN_DONE/$auto.iso" $auto

	umount -l $mnt
	rm -rf $mnt $auto

	if ($RTD_GUI --title "Created $auto.iso" --yesno "Would you like to test the new image?." 8 78); then
    		echo "User selected Yes, exit status was $?."
		check_dependencies qemu-kvm
		qemu-img create -f qcow2 "$PUT_QCOW_FILE_HERE_WHEN_DONE/$auto.qcow2" 10G
		qemu-system-x86_64 -smp 2 -enable-kvm -m 4G --cdrom "$PUT_ISO_FILE_HERE_WHEN_DONE/$auto.iso" "$PUT_QCOW_FILE_HERE_WHEN_DONE/$auto.qcow2"
	else
    		echo "User selected No, exit status was $?."
	fi
}




download_and_manipulate_iso_debian () {
	# This is a simple command sequence to read the preference of distribution to install
	# and what release to get... then download the network install file from ubuntu
	# and manipulate the iso file to complete the edited instruction in the preseed.cfg...
	: "${PRESEED_TEMPLATE:="https://github.com/vonschutter/Blind_Install/raw/master/custom/preseed.debian.template"}"
	: "${TARGET_ISO_FILE_NAME:="$1-$2-mini-netinstall-auto.iso"}"
	: "${SOURCE_ISO_URL:="https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/debian-10.2.0-amd64-netinst.iso"}"
	: "${SOURCE_FIRMWARE:="http://cdimage.debian.org/cdimage/unofficial/non-free/firmware/buster/current/firmware.zip"}"
	TARGET_ISO="$PUT_ISO_FILE_HERE_WHEN_DONE/$TARGET_ISO_FILE_NAME"
	PREFERENCE=$2
	
	echo -e $YELLOW Geting install image... 
	echo -e $GREEN Download: $SOURCE_ISO_URL $ENDCOLOR
	# Download the current version of Debian stable and extract its contents
	# to a known location.
	cd "$TMP_DOWNLOAD_DIR"
	wget -4  -q --show-progress "$SOURCE_ISO_URL" -O "./netboot.iso"
	"$BIN_7Z" x "./netboot.iso" "-o$TMP_DISC_DIR"
	echo -e $BLUE; ls $TMP_DISC_DIR ; echo -e $ENDCOLOR

	echo -e $YELLOW Geting non-free firmware... 
	echo -e $GREEN Download: $SOURCE_FIRMWARE $ENDCOLOR
	# By default Debian does not include non-free firmware to be able to use
	# some wireless cards; so these will need to be downloaded.
	wget -4  -q --show-progress "$SOURCE_FIRMWARE" -O "$TMP_DOWNLOAD_DIR/firmware.zip"
	mkdir $TMP_DISC_DIR/firmware
	"$BIN_7Z" x "$TMP_DOWNLOAD_DIR/firmware.zip" "-o$TMP_DISC_DIR/firmware"
	echo -e $BLUE ; ls $TMP_DISC_DIR/firmware ; echo -e $ENDCOLOR

	cd "$TMP_DISC_DIR"
	
	# Load the installation answers template.
	echo -e $YELLOW Getting intall instructions template... $ENDCOLOR
	mkdir -p $SCRIPT_DIR/custom
	wget -q --show-progress $PRESEED_TEMPLATE --output-document=$SCRIPT_DIR/custom/preseed.template

# ------------------- Patch 1 grub .cfg ------------------------ #

patch ./boot/grub/grub.cfg <<PATCH
11a12
> set timeout=10
13c14
< menuentry "Install" {
---
> menuentry "Automatic Install" {
PATCH

# -------------------------------------------------------------- #


# ---------------------Patch 2 isolinux.cfg -------------------- #

dos2unix "./isolinux/isolinux.cfg"
patch ./isolinux/isolinux.cfg <<PATCH_II
7c7
< timeout 0
---
> timeout 100
PATCH_II

# -------------------------------------------------------------- #

	# Edit the installation instructions file...
	cat "$SCRIPT_DIR/custom/preseed.template" > "$SCRIPT_DIR/custom/preseed.cfg"
	sed -i s/oem-replace-me-desktop-selection/$PREFERENCE/g "$SCRIPT_DIR/custom/preseed.cfg"
	cd "$TMP_INITRD_DIR"
	mkdir ./custom
	cp "$SCRIPT_DIR/custom/preseed.cfg" "./preseed.cfg"
	cp "$SSH_PUBLIC_KEY_FILE" "./custom/userkey.pub"

# ---------------------Create ssh key service ------------------ #

cat << SSH_KEY_KEYGEN > ./custom/ssh-host-keygen.service
[Unit]
Description=OpenSSH Server Key Generation
Before=ssh.service

[Service]
ExecStart=/usr/bin/ssh-keygen -A
Type=oneshot
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
SSH_KEY_KEYGEN

# -------------------------------------------------------------- #

	# Inject crated content into the new ISO...
	echo -e $GREEN "# Modify the CLI Installer" $ENDCOLOR 
	cat "$TMP_DISC_DIR/install.amd/initrd.gz" | gzip -d > "./initrd"
	echo "./preseed.cfg" | fakeroot "$BIN_CPIO" -o -H newc -A -F "./initrd"
	find "./custom" | fakeroot "$BIN_CPIO" -o -H newc -A -F "./initrd"
	cat "./initrd" | gzip -9c > "$TMP_DISC_DIR/install.amd/initrd.gz"
	rm ./initrd
	
	echo -e $GREEN "# Modify the GTK Installer" $ENDCOLOR 
	cat "$TMP_DISC_DIR/install.amd/gtk/initrd.gz" | gzip -d > "./initrd"
	echo "./preseed.cfg" | fakeroot "$BIN_CPIO" -o -H newc -A -F "./initrd"
	find "./custom" | fakeroot "$BIN_CPIO" -o -H newc -A -F "./initrd"
	cat "./initrd" | gzip -9c > "$TMP_DISC_DIR/install.amd/gtk/initrd.gz"

	rtd_oem_setup_brand_splash_screen
}



create_iso_image (){
	# Function to generate the new ISO file from the extracted and
	# altered original ISO.
	# Delete old iso file if there...
	echo "------ CREATING ISO: $TARGET_ISO    --------"
	if [ -f "$TARGET_ISO" ]; then
		rm -f "$TARGET_ISO"
	fi

	cd "$TMP_DISC_DIR"
	rm -r '[BOOT]'
	"$BIN_XORRISO" -as mkisofs -r -V "$VOLUME_TITLE" -J -b isolinux.bin -c boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table -input-charset utf-8 -isohybrid-mbr "$ISOHDPFX_BIN" -eltorito-alt-boot -e boot/grub/efi.img -no-emul-boot -isohybrid-gpt-basdat -o "$TARGET_ISO" ./
	chmod 777 "$TARGET_ISO" || read -p "An error may have occurred (review above outout) then: Press [ENTER] to continue:"
}



create_iso_image_debian (){
	# Function to generate the new ISO file from the extracted and
	# altered original ISO.
	# Delete old iso file if there...
	echo "------ CREATING ISO: $TARGET_ISO    --------"
	if [ -f "$TARGET_ISO" ]; then
		rm -f "$TARGET_ISO"
	fi

	cd "$TMP_DISC_DIR"
	rm -r '[BOOT]'
	"$BIN_XORRISO" -as mkisofs -r -V "$VOLUME_TITLE" -J -b "isolinux/isolinux.bin" -c boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table -input-charset utf-8 -isohybrid-mbr "$ISOHDPFX_BIN" -eltorito-alt-boot -e boot/grub/efi.img -no-emul-boot -isohybrid-gpt-basdat -o "$TARGET_ISO" ./
	chmod 777 "$TARGET_ISO" || read -p "An error may have occurred (review above outout) then: Press [ENTER] to continue:"
	}





make_qcow2 () {
	# Function to create a KVM virtual michine disk and define a VM. This function should be
	# used on a Qemu/KVM virtual host that the virtual guest is to be used on.
	# NOTE: QCOW2 is a storage format for virtual .
	# machine disk images QCOW stands for QEMU copy on write. The QCOW2 format decouples the physical storage
	# layer from the virtual layer by adding a mapping between logical and physical blocks.
	# NOTE2: Kernel-based Virtual Machine (KVM) is an open source virtualization technology built into LinuxÂ®.
	# Specifically, KVM lets you turn Linux into a hypervisor that allows a host machine to run multiple,
	# isolated virtual environments called guests or virtual machines (VMs). KVM is part of Linux.
	# For complete info: https://www.redhat.com/en/topics/virtualization/what-is-KVM
	# set -e
	# Use the check_dependencies function to make sure the needed software is available.
	check_dependencies qemu-img
	check_dependencies kvm
	# Lookup specific binaries: use full path since they may just have been added and not in $PATH yet.
	: "${BIN_QEMU_IMG:=$(type -P qemu-img)}"
	: "${BIN_KVM:=$(type -P kvm)}"

	# Get parameters if provided, otherwise use defaults.
	RAM_SIZE=${1:-"1024"}
	DISK_SIZE=${2:-"10G"}
	DISK_FORMAT=${3:-"qcow2"}
	DISK_FILE=${5:-"`pwd`/TARGET_ISO_FILE_NAME-$RAM_SIZE-$DISK_SIZE.$DISK_FORMAT"}

	# Verify ISO presesnce
		if [ -f "$TARGET_ISO" ]; then
			$RTD_GUI --backtitle "$BRANDING" --title "NOTICE!" --msgbox "OOOPS! You did a booboo... you have to first choose to create an ISO in the menu" 10 60
			clear
			exit
		fi

	# create image and run installer
	"$BIN_QEMU_IMG" create "$DISK_FILE" -f "$DISK_FORMAT" "$DISK_SIZE"
	"$BIN_KVM" -m "$RAM_SIZE" -cdrom "$TARGET_ISO" -boot once=d "$DISK_FILE"

	# remove tmp
	rm -r -f "$TMP_ISO_DIR"
}




set_install_command () {
	# add global install command for portability and convenience
	# If you need to use this script in an rpm based system you could modify the install
	# command here to suit dnf, yum, zypper... By default packages of patternd that do not
	# match should be skipped. Use "export option" so child processes also see the variiables.
	if [[ 'echo $OSTYPE" |grep "linux"' ]]; then
		if hash pkcon 2>/dev/null; then
			# If package kit is available then prefer this
			echo -e $YELLOW "Setting install options for Package Kit" $ENDCOLOR
			export _INSTCMD="pkcon -y  install"
		elif hash yum 2>/dev/null; then
			# If package kit is not available try yum (RedHat, Cent OS, Fedora)
			echo -e $YELLOW "Setting install options for YUM" $ENDCOLOR
			export _INSTCMD="yum -y  install"
		elif hash apt 2>/dev/null; then
			# If package kit is not available try apt (Debian, Ubuntu, and all derivatives)
			echo -e $YELLOW "Setting install options for DEB" $ENDCOLOR
			export _INSTCMD="apt-get -y -qq --allow-change-held-packages --ignore-missing install"
			export DEBIAN_FRONTEND=noninteractive
		elif hash zypper 2>/dev/null; then
			# If package kit is not available try zypper (Open SUSE)
			echo -e $YELLOW "Setting install options for ZYPPER" $ENDCOLOR
			export _INSTCMD="zypper install -y "
		else
			echo -e $YELLOW "This system does not seem to have a software managment system" $ENDCOLOR
			exit 1
		fi

	elif [[ "$OSTYPE" == "freebsd"* ]]; then
		echo "Free BSD is currently unsupported... "
		export _INSTCMD="echo I dont know how to install suff on FreeBSD!"
	else
	echo "I have no Idea what this system is"
		export _INSTCMD="Whatever!"
		exit 1
	fi
}



is_software_package_installed () {
	# Function to check if a piece of software is installed. This function will first check
	# if the package manager is deb, zypper or rpm, and then take one parameter passed
	# and evauate if a software package by that name is installed. This function
	# will return a "0" or "1" return based on the package managers return code.
	# Call this function by:
	# is_software_package_installed "package name"
	#                 or
	# is_software_package_installed "$1" if calling this function from a script
	# or another function receiving a parameter.
	#
	if hash yum 2>/dev/null; then
		rpm -q "$1" > /dev/null 2>&1 && return 0 || return 1
	elif hash apt 2>/dev/null; then
		dpkg -l "$1" 2>/dev/null |tail -1 |grep "ii  $1" > /dev/null 2>&1 && return 0 || return 1
	elif hash zypper 2>/dev/null; then
		zypper se "$1" > /dev/null 2>&1 && return 0 || return 1
	else
		return 3
	fi
}



is_software_package_available () {
	# Function to chek if a package is available in whetever repository, and
	# if there return a "0" and if not return a "1" or a "3" if there is no recognizable
	# package manager found. The function expects the name of the package
	# to be a parameter passed to this fuction. Call this function by:
	# is_software_package_available "package name"
	#                 or
	# is_software_package_available "$1" if calling this function from a script
	# or another function receiving a parameter.
	#
	# Supported base distributions: Fedora . SuSE . Debian
	if hash yum 2>/dev/null; then
		yum list available "$1" &> /dev/null && return 0 || return 1
	elif hash apt 2>/dev/null; then
		apt -qq list "$1" 2>/dev/null | grep -q "$1" && return 0 || return 1
	elif hash zypper 2>/dev/null; then
		return zypper info "$1" &> /dev/null && return 0 || return 1
	else
		return 3
	fi

	}



InstallSoftwareFromRepo () {
	# Function to simplify the installation of software by including all display and
	# installation logic for a given software provider. This should be expanded to include flatpack
	# snap for example. It should be the same consistent way no matter flavor of Linux.
	# This function uses the "$_INSTCMD" to install software. "$_INSTCMD" is defined separatley and could
	# be an RPM or deb string, or even snap or flatpack. A preference order between package system and
	# snap or flatpack use.

	# make some decent display terminal Graphics...
	# This function uses set_install_command and ensure_admin to be able to, and know how to, install a package...
	#
	set_install_command
	ensure_admin
	PAD="--------------------------------------------------"
	LINE=$(printf "%s %s" "$@" "$PAD" | cut -c 1-${#PAD})
	# Test if package name is installed, if not then...
	if ! is_software_package_installed "$@"; then
		if is_software_package_available   "$@"; then
		echo -ne "--- Installing "$LINE" ":" "\ & $_INSTCMD "$@" >>$LOGFILE.log 2>&1 && printf "%b%-6s%b [ \xE2\x9C\x94 ] $GREEN OK!$ENDCOLOR   \n" ||printf "%b%-6s%b [ ! ] $RED FAILED $ENDCOLOR  \n"
		else
		echo -ne "--- Installing "$LINE" ":" "\ && printf "%b%-6s%b [ \xE2\x9C\x94 ] $YELLOW Not available $ENDCOLOR \n"
		fi
	else
		echo -ne "--- Installing "$LINE" ":" "\ && printf "%b%-6s%b [ \xE2\x9C\x94 ] $YELLOW Already installed $ENDCOLOR \n"
	fi

}



check_dependencies () {
    # Function to check that a piece of software is installed and if not install it.
    # Works for apt, yum, and rpm based systems currently as long as the package name is the same.
    # The function will take a parameter that is expected to match the software command line name
    # or rather the name of the package. This function now relies on the return value of
    # the function "is_software_package_installed" as it is a more reliable way to see if a package of
    # software is installed according to the package manamgent system rather than the "hash" function
    # that checks if a command is available, since command name and package name are not allways the same...

	#---------------------------------------------------------------
        echo "Validating dependencies and installing them if not there..."
	#---------------------------------------------------------------
        if is_software_package_installed $1 ; then
		echo -e "$YELLOW $1 $ENDCOLOR is present on this system..."
        else
                echo -e "$YELLOW $1 $ENDCOLOR not found: I will try to get it... "
                InstallSoftwareFromRepo $1
                if [ $? != 0 ];
                then
                        echo -e $RED "That install didn't work out so well!"
                        echo -e "Please manually try to add the software since I couldn't do it." $ENDCOLOR
                        exit 1
                fi
        echo "OK Done! Continuing..."
        fi
}




rtd_update_system () {
        PUBLICATION="$BRANDING Update Manager for Linux"
        VERSION="1.13 (built in)"
        # System update function. The purpose of this function is to update installed software from
	# distribution reopositories and the newer self contained universal software stores like
        # snap and flatpak.
	LOGFILE="${LOGFILE:=$0}"


        echo -e $GREEN"$PUBLICATION: Version $VERSION" $ENDCOLOR
        echo -e $GREEN"------------------------------------------------" $ENDCOLOR

        echo I am updating software from all channels i can find on the system.
        echo I will update via the native package manager as well as newer formats
        echo -e "like $YELLOW"snap"$ENDCOLOR and $YELLOW"flatpak"$ENDCOLOR..."
        echo " "


        log_item ()
        {
                DATE=$(date '+%d/%m/%Y %H:%M:%S');
                echo "$DATE --- : $@" >> $LOGFILE
        }

        deb_software_task ()
        {
                log_item "running deb_software_task with parameters $@"
                # make some decent display terminal graphics...
                PAD="------------------------------------------"
                LINE=$(printf "%s %s" "$@" "$PAD" | cut -c 1-${#PAD})
                echo -ne "--- Executing "$LINE"":""\ & $@ >>$LOGFILE 2>&1 && printf "%b%-6s%b [ \xE2\x9C\x94 ] $GREEN OK!$ENDCOLOR   \n" ||printf "%b%-6s%b [ ! ] $RED FAILED $ENDCOLOR  \n"
        }
        # Update native software packages; since it is not known what distribution
	# this script is being executed on, it is best to check and see if we are able
	# to perform an update and then do the update...
	# One could choose to check for a supported exact version: e.g. Ubuntu, but we would
	# like to be nice and add value for as many as we can. Specially if it is this easy! :)
	if hash pkcon 2>/dev/null; then
		# If package kit is available then prefer this
		echo -e $YELLOW "Using: Package Kit" $ENDCOLOR
		pkcon -y refresh 2>> $LOGFILE
		pkcon -y update 2>> $LOGFILE
		#| $RTD_GUI --gauge "Updating native packages..." 6 50 0
	elif hash yum 2>/dev/null; then
		# If package kit is not available try yum (RedHat, Cent OS, Fedora)
		echo -e $YELLOW "Using: YUM" $ENDCOLOR
		deb_software_task yum -y upgrade 2>> $LOGFILE
	elif hash apt 2>/dev/null; then
		# If package kit is not available try apt (Debian, Ubuntu, and all derivatives)
		echo -e $YELLOW "Using: DEB" $ENDCOLOR
		deb_software_task apt-get update
		deb_software_task apt-get upgrade -y
		deb_software_task apt-get autoremove -y
	elif hash zypper 2>/dev/null; then
		# If package kit is not available try zypper (Open SUSE)
		echo -e $YELLOW "Using: ZYPPER" $ENDCOLOR
		deb_software_task zypper up -y 2>> $LOGFILE
	else
		echo -e $YELLOW "This system does not seem to have a software managment system" $ENDCOLOR
		exit 1
	fi

        # updating snaps if snap is present on the system...
        if hash snap 2>/dev/null; then
                snap refresh 2>> $LOGFILE
		#| $RTD_GUI --gauge "Updating snap packages..." 6 50 0
        else
                echo "--- snap software is not present on this system... skipping..."
        fi

        # updating flatpacks if flatpack is present on system...
        if hash flatpak 2>/dev/null; then
                flatpak update -y 2>> $LOGFILE
		#| $RTD_GUI --gauge "Updating flapak packages..." 6 50 0
        else
                echo "--- flatpak software is not present on this system... skipping..."
        fi
}



backup_running_vm () {
	# Function to back up all funning virtual machines on the host it is being run on.
	# This function should be called from within this script and down not require any
	# parameters passed.
	clear
	ensure_admin
	if hash virsh ; then
		echo Virtual Machinces on this system:
		echo " "
		virsh list --all
	else
		echo KVM Virtualization is not installed on this machine.
	fi

	# To exclude a VM (domain), add "nobackup" to its name and it will be ignored.
	# To rename: shutdown the guest, then use this command: virsh domrename "oldname" "newname".

	DATE=`date +%Y-%m-%d.%H:%M:%S`
	LOG=${LOGFILE:="/var/log/kvm-backup.$DATE.LOG"}
	BACKUPROOT=${VM_BACKUP_TARGET:=/mnt/vmdsk/VM_BACKUP}

	#Get list of all running virtual machines
	DOMAINS=$(virsh list --all | tail -n +3 | awk '{print $2}')

	for DOMAIN in $DOMAINS; do
		echo "-----------WORKER START $DOMAIN-----------" > $LOG
		echo "Starting backup for $DOMAIN on $(date +'%d-%m-%Y %H:%M:%S')"  >> $LOG

		if [[ $DOMAIN == *"nobackup"* ]];then
		        echo "Skipping $DOMAIN , because its excluded." > $LOG
		        exit 1
		fi

		VMSTATE=`virsh list --all | grep $DOMAIN | awk '{print $3}'`
		if [[ $VMSTATE != "running" ]]; then
		        echo "Skipping $DOMAIN , because its not running." > $LOG
		        exit 1
		fi

		BACKUPFOLDER=$BACKUPROOT/KVM-BACKUPS/$DOMAIN
		mkdir -p $BACKUPFOLDER
		TARGETS=$(virsh domblklist $DOMAIN --details | grep disk | awk '{print $3}')
		IMAGES=$(virsh domblklist $DOMAIN --details | grep disk | awk '{print $4}')
		DISKSPEC=""
		for TARGET in $TARGETS; do
		        DISKSPEC="$DISKSPEC --diskspec $TARGET,snapshot=external"
		done

		virsh snapshot-create-as --domain $DOMAIN --name "backup-$DOMAIN" --no-metadata --atomic --disk-only $DISKSPEC >> $LOG
		if [ $? -ne 0 ]; then
		        echo "Failed to create snapshot for $DOMAIN" > $LOG
		        exit 1
		fi

		for IMAGE in $IMAGES; do
		        NAME=$(basename $IMAGE)
		        if test -f "$BACKUPFOLDER/$NAME"; then
		        echo "Backup exists, merging only changes to image" > $LOG
		        rsync -apvz --inplace $IMAGE $BACKUPFOLDER/$NAME >> $LOG
		        else
		        echo "Backup does not exist, creating a full sparse copy" > $LOG
		        rsync -apvz --sparse $IMAGE $BACKUPFOLDER/$NAME >> $LOG
		        fi
		done

		BACKUPIMAGES=$(virsh domblklist $DOMAIN --details | grep disk | awk '{print $4}')
		for TARGET in $TARGETS; do
		        virsh blockcommit $DOMAIN $TARGET --active --pivot >> $LOG

		        if [ $? -ne 0 ]; then
		                echo "Could not merge changes for disk of $TARGET of $DOMAIN. VM may be in invalid state." > $LOG
		                exit 1
		        fi
		done

		for BACKUP in $BACKUPIMAGES; do
		        if [[ $BACKUP == *"backup-"* ]];then

		        echo "deleted temporary image $BACKUP" > $LOG
		        rm -f $BACKUP
		        fi
		done

		virsh dumpxml $DOMAIN > $BACKUPFOLDER/$DOMAIN.xml
		echo "-----------WORKER END $DOMAIN-----------" >> $LOG
		echo "Finished backup of $DOMAIN at $(date +'%d-%m-%Y %H:%M:%S')" >> $LOG
done
}



rtd_ppa_checker () {
  for f in /etc/apt/sources.list.d/*.list; do
    grep -Po "(?<=^deb\s).*?(?=#|$)" "$f" | while read -r ENTRY ; do
    echo "ENTRY: $ENTRY"
        HOST=$(cut -d/ -f3 <<< "$ENTRY")

        if [ "ppa.launchpad.net" = "$HOST" ]; then
		USER=$(cut -d/ -f4 <<< "$ENTRY")
		PPA=$(cut -d/ -f5 <<< "$ENTRY")
		packageCount=$(awk '$1=="Package:" {if (a[$2]++ == 0) {system("dpkg -l "$2)}}' /var/lib/apt/lists/*"$USER"*"$PPA"*Packages 2>/dev/null | awk '/^ii/' | wc -l)
		echo "PPA: ppa:$USER/$PPA"
		echo "FILENAME: $f"
		echo "$packageCount package(s) installed"
		if [ "$packageCount" -eq 0 ] && [ "$1" == "--delete" ]; then
		sudo rm "$f" && echo "$f deleted"
		fi
		echo
        else
		USER=$(cut -d/ -f3 <<< "$ENTRY")
		PPA=$(cut -d/ -f4 <<< "$ENTRY")
		packageCount=$(awk '$1=="Package:" {if (a[$2]++ == 0) {system("dpkg -l "$2)}}' /var/lib/apt/lists/*"$USER"*Packages 2>/dev/null | awk '/^ii/' | wc -l)
		echo "REPOSITORY: $USER/$PPA"
		echo "FILENAME: $f"
		echo "$packageCount package(s) installed"
		if [ "$packageCount" -eq 0 ] && [ "$1" == "--delete" ]; then
			sudo rm "$f" && echo "$f deleted"
		fi
		echo
        fi
    done
done
}




dl () {
	# Function to ease and make consistent the downloading of the non repository packages and
	# install them. This function presently only works with apt. This should be expanded to include
	# RPM packages as well.
	# First parameter is the URL, second is the name of the deb, to bypass version
	# naming issues, use wildcards like skype*.deb
	check_dependencies wget
	echo -e $YELLOW "   - Geting package $2 ..." $ENDCOLOR
	wget -P /var/apt/cache/archives/ $1
	echo -e YELLOW "    - Installing package $2 ..." $ENDCOLOR

	if hash pkcon 2>/dev/null; then
		pkcon install-local -y /var/apt/cache/archives/$2
    	else
        	echo "You seem to have no Package Kit... I will try to get it... "
        	echo "I will need to become admin to do that..."
        	sudo check_dependencies packagekit
			if [ $? != 0 ];
			then
				echo "That install didn't work out so well."
				echo "Please install Package Kit and try again, or install $2 manually"
				read -p "Press [Enter] key to return to the main menu: "
        		fi
		echo "OK trying again!"
		pkcon install-local -y /var/apt/cache/archives/$2
	fi
}





rtd_oem_find_ubuntu_release()
{
	# 18.04 and later need to use the alternative installer
	# since the switch to subiquity
	if [ ${1:0:2} -ge 18 ]; then
        rel=http://cdimage.ubuntu.com/releases/$1/release
		echo $rel/$(curl --silent $rel/MD5SUMS | \grep -o 'ubuntu-.*-server-amd64.iso')
    else
		rel=http://releases.ubuntu.com/$1
		echo $rel/$(curl --silent $rel/MD5SUMS | \grep -o 'ubuntu-.*-server-amd64.iso')
	fi
}




kickstart-cfg()
{
	echo en > $1/isolinux/lang
	cat > $1/isolinux/isolinux.cfg <<- EOF
		default install
		label install
		  menu label ^Install Ubuntu Server
		  kernel /install/vmlinuz
		  append file=/cdrom/preseed/ubuntu-server.seed initrd=/install/initrd.gz ks=cdrom:/ks.cfg preseed/file=/cdrom/ks.preseed --
	EOF
	# add uefi support
	cat > $1/boot/grub/grub.cfg <<- EOF

		if loadfont /boot/grub/font.pf2 ; then
		  set gfxmode=auto
		  insmod efi_gop
		  insmod efi_uga
		  insmod gfxterm
		  terminal_output gfxterm
		fi

		set default=0
		set timeout=1
		set menu_color_normal=white/black
		set menu_color_highlight=black/light-gray
		menuentry "Automated Install of Ubuntu Server" {
		  set gfxpayload=keep
		  linux /install/vmlinuz  file=/cdrom/preseed/ubuntu-server.seed ks=cdrom:/ks.cfg preseed/file=/cdrom/ks.preseed ---
		  initrd /install/initrd.gz
		}
		}
	EOF

	# To fully automate the Ubuntu install using the server install media
	# both ks.cfg and preseed technologies must be used. Each section tn the preeseed 
	# is broken out and can be configured separatley. this si for logic and readability. 
	touch $1/ks.preseed
	rtd_oem_preseed_ubuntu_cfg_KS.CFG.Options $1
	rtd_oem_preseed_ubuntu_cfg_Unattended.Install $1
	rtd_oem_preseed_ubuntu_cfg_Network.Configuration $1
	rtd_oem_preseed_ubuntu_cfg_Account.Setup $1
	rtd_oem_preseed_ubuntu_cfg_Prevent.Install.On.USB $1
	rtd_oem_preseed_ubuntu_cfg_EFI $1
	rtd_oem_preseed_ubuntu_cfg_GRUB.Bootloader.Installation $1
	rtd_oem_preseed_ubuntu_cfg_Disk.Layout $1
	rtd_oem_preseed_ubuntu_cfg_Package.Selection $1 kubuntu-desktop
	rtd_oem_preseed_ubuntu_cfg_Addon.Tasks $1
}



rtd_oem_preseed_ubuntu_cfg_KS.CFG.Options () 
{
	cat > $1/ks.cfg <<- EOF
		# --------------------------------------------------- #
		# KS.CFG Options
		# --------------------------------------------------- #
		# Simple instruction to tell the Ubuntu installer that
		# this is intended to be an unattended install and to only
		# ask critical questions (wich we will answer in this file)
		# Add options here from these instructions: 
		#
		# https://pykickstart.readthedocs.io/en/latest/kickstart-docs.html#chapter-2-kickstart-commands-in-fedora
		#
		# Please note that some options in kickstart are superceeded by preseed.
		#
		lang en_US.UTF-8
		keyboard se
		timezone $(cat /etc/timezone)
		install
		cdrom
		bootloader --location=mbr
		zerombr yes
		clearpart --all --initlabel
		skipx
		reboot

		# --------------------------------------------------- #
	EOF
}



rtd_oem_preseed_ubuntu_cfg_Unattended.Install () 
{
	cat >> $1/ks.preseed <<-'EOF'
		# --------------------------------------------------- #
		# Unattended Installation
		# --------------------------------------------------- #
		# Simple instruction to tell the debian installer that
		# this is intended to be an unattended install and to only
		# ask critical questions (wich we will answer in this file)
		d-i auto-install/enable boolean true
		d-i debconf/priority select critical 
		# --------------------------------------------------- #
	EOF
}


rtd_oem_preseed_ubuntu_cfg_Network.Configuration () 
{
	cat >> $1/ks.preseed <<-'EOF'
		
		# --------------------------------------------------- #
		# Network configuration
		# --------------------------------------------------- #
		# Network setup. This can be a static setup or dhcp. 
		# d-i netcfg/choose_interface select auto
		d-i netcfg/hostname string RTD-Client
		d-i netcfg/get_hostname string unassigned-hostname
		d-i netcfg/get_domain string unassigned-domain
		d-i hw-detect/load_firmware boolean true

		# We want the preconfiguration file to work on systems both with and
		# without sucessful dhcp configuration
		d-i netcfg/dhcp_failed note
		d-i netcfg/dhcp_options select Configure network manually
		# d-i netcfg/dhcp_timeout string 60

		d-i netcfg/wireless_show_essids select manual
		d-i netcfg/wireless_essid string loader
		d-i netcfg/wireless_essid_again string loader
		d-i netcfg/wireless_security_type select wpa
		d-i netcfg/wireless_wpa string letmein1234

		# --------------------------------------------------- #
	EOF
}


rtd_oem_preseed_ubuntu_cfg_Account.Setup () 
{
	cat >> $1/ks.preseed <<-'EOF'
		# --------------------------------------------------- #
		# Account setup (temporary user account)
		# --------------------------------------------------- #
		# Setup an initial user and disable root login by default. 
		# root login may be re-enabled later by setting a root password.
		# An encrypted password is set here, and should be changed
		# ASAP after the system is built. Preferebly connect to LDAP/AD
		# in a managed environment.
		d-i passwd/root-login boolean false
		d-i passwd/user-fullname string Ubuntu User
		d-i passwd/username string tangarora
		d-i passwd/user-password-crypted password $6$Rn5/UTzjIs68MX$9gz8vmshGlPqse3VoX8dzSfhWxRVoYv1MB6aGRD8xdvztOf.gD.SxxVWkxYrwwbShB9Q14flquK/apbdQJ65t1
		d-i passwd/auto-login boolean true

		# --------------------------------------------------- #
	EOF
}


rtd_oem_preseed_ubuntu_cfg_Prevent.Install.On.USB () 
{
	cat >> $1/ks.preseed <<-'EOF'
		# --------------------------------------------------- #
		# Do NOT install on the USB stick(!)
		# --------------------------------------------------- #
		#
		# The Debian installer will install on the first disk it finds which can
		# sometimes be the USB stick itself. Work around this by rolling our own auto
		# detect logic which disallows installing on USB devices.
		#
		# d-i partman/early_command string [ "$(ls -A /tmp)" ] && umount -l /media || echo "Empty" ;
		d-i partman/early_command string \
			USBDEV=$(mount | grep hd-media | cut -d" " -f1 | sed "s/\(.*\)./\1/");\
			BOOTDEV=$(list-devices disk | grep -v \$USBDEV | head -1);\
			debconf-set partman-auto/disk $BOOTDEV;\
			debconf-set grub-installer/bootdev $BOOTDEV;

		# --------------------------------------------------- #
	EOF
}


rtd_oem_preseed_ubuntu_cfg_EFI () 
{
	cat >> $1/ks.preseed <<-'EOF'
		# --------------------------------------------------- #
		# EFI
		# --------------------------------------------------- #
		#
		# The EFI (Extensible Firmware Interface) system partition is a partition on a data storage device.
		# UEFI provides backward compatibility with legacy systems by reserving the first block (sector) of 
		# the partition for compatibility code, effectively creating a legacy boot sector. On legacy BIOS-based 
		# systems, the first sector of a partition is loaded into memory and execution is transferred to this code. 
		# Here we tell setup to install EFI boot setup if possible so that both NEW and old systems may be handled
		# and the installed system can be started.
		d-i partman-efi/non_efi_system boolean true
		# --------------------------------------------------- #
	EOF
}



rtd_oem_preseed_ubuntu_cfg_GRUB.Bootloader.Installation () 
{
	cat >> $1/ks.preseed <<-'EOF'
		# --------------------------------------------------- #
		# GRUB bootloader installation
		# --------------------------------------------------- #
		#
		# Tell the grub-installer to install to the MBR even if it also finds some other
		# OS, which is more likely to allow the newly installed Linux OS to boot without issue.
		d-i grub-installer/only_debian boolean true
		d-i grub-installer/with_other_os boolean true
		# --------------------------------------------------- #
	EOF
}



rtd_oem_preseed_ubuntu_cfg_Disk.Layout () 
{
	cat >> $1/ks.preseed <<-'EOF'
		# --------------------------------------------------- #
		#   Disk layout   
		# --------------------------------------------------- #
		#
		## Set option to encrypt the hard disk:
		d-i partman-auto/method string crypto

		# Option to temporarily set full disk encryption password to automate the install below. 
		# If you prefer to be propmpted during the system installation process comment out the 
		# two crypto/passphrase options below. The disk encryption password can be changed at 
		# anytime once the system is installed using the following command: 
		#
		#		tool      :   command   : device and partition number
		#               cryptsetup luksChangeKey /dev/sda4 
		#
		#
		d-i partman-crypto/passphrase password letmein1234
		d-i partman-crypto/passphrase-again password letmein1234
		# DO Please remember to change this password after install!!!!
		# You may do this with the cryptsetup utility on a server, or using the "disks"  tool. 
		# Alternatively this is easily done with the rtd-simple-server-support-tool under 
		# "Manage encryption phrases and passwords" where you can check if the phrase you want to use
		# has been p0wned and currently for sale or not. 
		# When disk encryption is enabled, skip wiping the partitions beforehand since it takes too much time.
		d-i partman-auto-crypto/erase_disks boolean false
		# Delete anything on the first hard drive, then define the actual layout of the disk 
		# using and encrypted LVM volume for security. 
		d-i partman-lvm/device_remove_lvm boolean true
		d-i partman-lvm/device_remove_lvm_span boolean true
		d-i partman-auto/purge_lvm_from_device boolean true
		d-i partman-lvm/confirm boolean true
		d-i partman-lvm/confirm_nooverwrite boolean true
		d-i partman-auto-lvm/guided_size string max
		d-i partman-auto-lvm/new_vg_name string crypt
		# Use vda & sda to ensure recipie is applied even if this installis run in a KVM VM.
		# d-i partman-auto/disk string /dev/sdb 
		d-i partman-auto/choose_recipe select root-encrypted
		d-i partman-auto/expert_recipe string                   \
		root-encrypted ::                                       \
				538 538 1075 free                       \
				$primary                                \
				$iflabel{ gpt }                         \
				$reusemethod{ }                         \
				method{ efi } format{ }                 \
			.                                               \
			500 500 500 ext3                                \
				$primary{ } $bootable{ }                \
				method{ format } format{ }              \
				use_filesystem{ } filesystem{ ext4 }    \
				mountpoint{ /boot }                     \
									\
			.                                               \
			2000 2000 2000 linux-swap                       \
				$lvmok{ } lv_name{ swap }               \
				in_vg { crypt }                         \
				$primary{ }                             \
				method{ swap } format{ }                \
			.                                               \
			500 10000 1000000000 ext4                       \
				$lvmok{ } lv_name{ root }               \
				in_vg { crypt }                         \
				$primary{ }                             \
				method{ format } format{ }              \
				use_filesystem{ } filesystem{ ext4 }    \
				mountpoint{ / }                         \
			.                                               \
			2000 2000 2000 ext4                             \
				$primary{ }                             \
				method{ keep }                          \
				use_filesystem{ } filesystem{ ext4 }    \
				label{ rescuedisk }                     \
			.

		d-i partman-md/device_remove_md boolean true
		d-i partman-md/confirm boolean true
		d-i partman-basicfilesystems/no_mount_point boolean false
		d-i partman-partitioning/confirm_write_new_label boolean true
		d-i partman/choose_partition select finish
		d-i partman/confirm boolean true
		d-i partman/confirm_nooverwrite boolean true
		# --------------------------------------------------- #
	EOF
}




rtd_oem_preseed_ubuntu_cfg_Package.Selection () 
{
	cat >> $1/ks.preseed <<-EOF
		# --------------------------------------------------- #
		# Package selection
		# --------------------------------------------------- #
		# Packages may be selected as groups (meta packages) like kde-desktop or
		# as individual packages. Only one "pkgsel/include" string will be used though! 
		# remembder to fit all the packages you want on one line. 
		# tasksel tasksel/first multiselect standard options: 
		# [ubuntu-desktop-minimal kubuntu-desktop, ubuntu-gnome-desktop, lubuntu-desktop, ubuntu-mate-desktop]
		# tasksel tasksel/first multiselect kubuntu-desktop
		d-i pkgsel/include string openssh-server virt-what wget spice-vdagent $2

		# Valid choices for pkgsel/upgrade are: safe-upgrade full-upgrade none
		d-i pkgsel/upgrade select none
		d-i pkgsel/update-policy select unattended-upgrades

		# By default, the systemâs locate database will be updated after the
		# installer has finished installing most packages. This may take a while, so
		# if you donât want it, you can set this to "false" to turn it off.
		# d-i pkgsel/updatedb boolean false
		# --------------------------------------------------- #
	EOF
}


rtd_oem_preseed_ubuntu_cfg_Addon.Tasks () 
{
	cat >> $1/ks.preseed <<-'EOF'
		# --------------------------------------------------- #
		# Addon Tasks
		# --------------------------------------------------- #
		# d-i preseed/late_command string can be used to run shell commands just 
		# before the Preseed process ends. Just like, early_command, there can 
		# only be one instance of it. If you have multiple instances of it, 
		# the last instance will be the one to run. The other instances will be ignored.
		#
		# Option to include the ssh keys so that the system easily can be logged in to
		# via remote ssh. This is usefull for server setups but not neccessarily for desktops.
		# The commands below will copy your own ssh authentication files in to the media.
		# Uncoment the below options to enable this:

		d-i preseed/late_command string \
			mkdir -p /target/opt/rtd/scripts; \
			mkdir -p /target/opt/rtd/log; \
			cp -r /custom /target/opt/rtd/custom; \
			cp /preseed.cfg /target/opt/rtd/log/; \
			in-target wget -O /opt/rtd/scripts/post-install.sh "https://github.com/vonschutter/Blind_Install/raw/master/custom/task.sh" --no-check-certificate ; \
			in-target chmod +x /opt/rtd/scripts/post-install.sh; \
			in-target /opt/rtd/scripts/post-install.sh; \
			umount -l /media || echo "Empty"; \
			eject || true; \
			echo "------  initial Setup Complete!  ------" 

		# Answer the last question 
		d-i debian-installer/splash boolean true

		# Option to try to greacefully eject the installation media:
		d-i cdrom-detect/eject boolean true

		# Shutdown machine
		d-i finish-install/reboot_in_progress note
		#d-i debian-installer/exit/poweroff boolean true

		# --------------------------------------------------- #
	EOF
}






#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::            Tool GUI Functions            ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
# Functions that control how the the RTD menus are displayed are listed below
# in this section for better manageability. When scripts become rather large
# they become cumbersome to manage, then it is sometimes helpful to sections
# in some logical order.
BRAND="  $BRANDING		Verson:$RTD_Version : on $HOSTNAME"
BRANDING=$BRAND

display_result () {
        $RTD_GUI --backtitle "$BRANDING" --title "$1" \
        --msgbox "$result" 20 80
}



display_notice () {
	# Function to display a notice that the ISO creation is complete.
	# And describe what to de next.
	$RTD_GUI --backtitle "$BRANDING" \
	--title "About" \
	--msgbox "
This tool is part of the RTD System Support Tools. The purpose of this tool is to generate an unattended installation ISO file that can be used directly by a virtual machine in KVM, Oracle Virtual Box, or VMware. Alternatively, this Image may be appled to a thumb drive using "dd" or "etcher", or burned to optical media using "K3B" or another favorite CD/DVD burining software.

This script will:
  - Download the latest installation image
  - Patch the installation image with the instructions to complete an install
  - The instructios will encrypt the hard drive and install, automatically.
  - The disk encryption password is: "letmein1234"
  - The system login and admin temporary password is: "letmein""  20 80
}



show_notice_on_fist_run () {
	if [ -f ~/.config/rtd-first-run-$RTD_Version ]; then
		echo $RTD_Version has been used already and terms reviewed...
	else
		show_notice_on_fist_run_TEXT="
This looks like the first time you run this vesion of the RTD tools. Please note that these tools are provided as-is and for modification.

The RTD tools run in a separate terminal that you can re connect to if you should get disconnected. This can be done by:
- re-connecting to the server with ssh
- then running command "byobu" if a session is already running on the server"

		$RTD_GUI --backtitle "$BRANDING" --title "DONE" --msgbox "$show_notice_on_fist_run_TEXT" 15 80
		touch ~/.config/rtd-first-run-$RTD_Version
		clear
	fi


}



cleanup_and_finish () {
	# Function to remove all temporary file locations left over from building
	# the new netinstall ISO.
	# go back to initial directory
	cd "$CURRENT_DIR"
	# Cleanup folder structure...
	rm -r "$TMP_DOWNLOAD_DIR"
	rm -r "$TMP_DISC_DIR"
	rm -r "$TMP_INITRD_DIR"
	rm -r "$SCRIPT_DIR/custom"





	COMPLETION_MESSAGE="	Your ISO image is ready!
	It is placed in the folder: $PUT_ISO_FILE_HERE_WHEN_DONE/
	Next steps:
	- Burn the ISO to a USB (ex: using MULTIBOOT from Pendrive Linux)
	- If you are using Virtual Machines select the ISO as install media
	- Boot from the media created: allow it to install the system
	- login as the temporary user (temporary password: letmein)
	- Adjust passwords for the encrypted volume and login... "
            $RTD_GUI --backtitle "RTD OEM System Builder" --title "DONE" --msgbox "$COMPLETION_MESSAGE" 15 80

	# Print COMPLETION_MESSAGE
	BIN_7Z=
	BIN_XORRISO=
	BIN_CPIO=
	ISOHDPFX_BIN=
	VOLUME_TITLE=
	TARGET_ISO_FILE_NAME=
	SOURCE_ISO_URL=
	SSH_PUBLIC_KEY_FILE=
	PRESEED_TEMPLATE=
	clear
	show_main_menu
}




rtd_setup_choices_cli_workstation () {
	# Function to display legacy installation options. This will install software that is usefull
	# on a really old system, or a remote system only accessible via SSH. This may be a good
	# usecase if you happen to be in an opressed geographic locaiton where your only option is
	# to ssh to a remote server and access email and web that way. Perfomance in these cases
	# may be very poor over the internet (as for example with the great firewall of China). In
	# Such a case it would be usefull to have the good old CLI software! :)
	# List Options to be available for choice in the RTD System Configurator...
	cmd=($RTD_GUI --backtitle "$BRANDING" --title "Terminal Software add on Options Menu" --separate-output --checklist "You can be productive in the cli environment. Please Select Software titles below that you want to add to this system:" 22 85 16 )
	options=(1 "Base RTD OEM Software (basic admin tools usually needed)" on
		 2 "Alpine email client" off
		 3 "Vim text editor" on
		 4 "Finch multi protocol chat" off
		 5 "Word Grinder word precessor" off
		 6 "Spreadsheet Calculator" off
		 7 "TPP Presentation Program" off
		 8 "Midnight Commander file manager (Norton Commander)" on
		 9 "Cmus Music Player" off
		 10 "Byobu Terminal Window Manger" off
		 11 "W3M web Browser" off
		 12 "LYNX Web Browser (Browse the web directly in the terminal)" off
		 13 "Mega.nz command line tools (Mega-CMD)" off
		 14 "Rtorrent torrent download software" off
		 15 "Install the OpenVpn client Software" off
		 16 "Games: Freesweep mine sweep game" off
		 17 "Games: Bastet Tetris Game" off
		)

			choices=$("${cmd[@]}" "${options[@]}" 2>&1 >/dev/tty)
			clear
			for choice in $choices
			do
			    case $choice in
				1)
				for i in wine-stable ffmpeg netstat nmcli htop powertop iftop monit nethogs bmon darkstat ss mtr glances nmap iostat multitail ncdu multitail ; do InstallSoftwareFromRepo $i ; done
				;;
				2)
				InstallSoftwareFromRepo alpine
				;;
				3)
				InstallSoftwareFromRepo vim
				;;
				4)
				InstallSoftwareFromRepo finch
				;;
				5)
				InstallSoftwareFromRepo wordgrinder
				;;
				6)
				InstallSoftwareFromRepo sc
				;;
				7)
				InstallSoftwareFromRepo tpp
				;;
				8)
				InstallSoftwareFromRepo mc
				;;
				9)
				InstallSoftwareFromRepo cmus
				;;
				10)
				InstallSoftwareFromRepo byobu
				;;
				11)
				InstallSoftwareFromRepo w3m
				;;
				12)
				InstallSoftwareFromRepo lynx
				;;
				13)
				dl https://mega.nz/linux/MEGAsync/xUbuntu_19.04/amd64/ megacmd-*.deb
				;;
				14)
				InstallSoftwareFromRepo rtorrent
				;;
				15)
				InstallSoftwareFromRepo openvpn
				;;
				16)
				InstallSoftwareFromRepo freesweep
				;;
				17)
				InstallSoftwareFromRepo bastet
				;;
			esac
		done
}




show_make_media_gui () {
	# List Options to be available for choice in the RTD System Configurator...
	while true; do
		exec 3>&1
		selection=$($RTD_GUI \
		--backtitle "$BRANDING" --title "ISO Menu"  --menu "Creating the ISO file is complete, what do you want to do now?: \
                You may choose to create and automatic Installer ISO (Burn to CD, USB, or use with VM)." 0 0 4 \
		"1" "Generate an Automatic Install ISO for Ubuntu Standard Desktop (more MAC like)" \
		"2" "Generate an Automatic Install ISO for Ubuntu with Plasma Desktop (more Windows like)" \
		"3" "Generate an Automatic Install ISO for Ubuntu Gnome (without Ubuntu customization)" \
                "4" "Generate an Automatic Install ISO for Ubuntu Minimal Standard desktop" \
		"5" "Generate an Automatic Install ISO for Graphical Server (Xubuntu-core)" \
		"6" "Generate an Automatic Install ISO for Debian Default Desktop" \
		"7" "Generate an Automatic Install ISO for Debian Light Weight Desktop" \
		"8" "Generate an Automatic Install ISO for Debian Plasma Desktop" \
		"9" "Generate an Automatic Install ISO for Debian Graphical Server" \
		"10" "Generate an Automatic Install ISO for Debian Minimal Server (Core)" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-

		case $exit_status in
		$DIALOG_CANCEL)
		echo "Returning to main menu..."
		show_main_menu
		;;
		$DIALOG_ESC)
		echo "Program aborted." >&2
		exit 1
		;;
		esac

		case $selection in
		0 )
			clear
			echo "Program terminated by user..."
		;;
		1 )
			clear
			rtd_oem_ubuntu_auto_install_iso_builder ubuntu-desktop
			clear
		;;
		2 )
			clear
			rtd_oem_ubuntu_auto_install_iso_builder kubuntu-desktop
			cleanup_and_finish
			clear
		;;
		3 )
			clear
			rtd_oem_ubuntu_auto_install_iso_builder ubuntu-gnome-desktop
			cleanup_and_finish
			clear
		;;
                4 )
			clear
			rtd_oem_ubuntu_auto_install_iso_builder ubuntu-desktop-minimal
			cleanup_and_finish
			clear
		;;
		5 )
			clear
			rtd_oem_ubuntu_auto_install_iso_builder xubuntu-core
			cleanup_and_finish
			clear
		;;
		6 )
			clear
			prepare_environment_for_iso_creation
			download_and_manipulate_iso_debian debian desktop
			create_iso_image_debian
			cleanup_and_finish
			clear
		;;
		7 )
			clear
			prepare_environment_for_iso_creation
			download_and_manipulate_iso_debian debian cinnamon-desktop
			create_iso_image_debian
			cleanup_and_finish
			clear
		;;
		8 )
			clear
			prepare_environment_for_iso_creation
			download_and_manipulate_iso_debian debian kde-desktop
			create_iso_image_debian
			cleanup_and_finish
			clear
		;;
		9 )
			clear
			prepare_environment_for_iso_creation
			download_and_manipulate_iso_debian debian lxde-desktop
			create_iso_image_debian
			cleanup_and_finish
			clear
		;;
		10 )
			clear
			prepare_environment_for_iso_creation
			download_and_manipulate_iso_debian debian ssh-server
			create_iso_image_debian
			cleanup_and_finish
			clear
                ;;
		esac
	done
}

show_manage_vm_gui () {
	# List Options to be available for choice in the RTD System Configurator...
	while true; do
	exec 3>&1
	selection=$($RTD_GUI \
	--backtitle "$BRANDING" \
	--title "VM Managment Menu"  \
	--menu "Please select what you would like to do below:"  0 0 4 \
	"1" "List all virtual machines on this system" \
	"2" "Backup all running virtual machines on this server" \
	"3" "Generate boot media for auto installing a virtual machine on this server (Ubuntu and others)" \
	2>&1 1>&3 )
	exit_status=$?
	exec 3>&-

	case $exit_status in
	$DIALOG_CANCEL)
		echo "Returning to main menu..."
		show_main_menu
	;;
	$DIALOG_ESC)
		echo "Program aborted." >&2
		exit 1
	;;
	esac

	case $selection in
	0 )
		clear
		echo "Program terminated by user..."
	;;
	1 )
		clear
		if hash virsh ; then
			result=$(virsh list --all )
			display_result "Virtual Machinces on this system:"
		else
			echo KVM Virtualization is not installed on this machine.
		fi
		clear
	;;
	2 )
		clear
		if hash virsh ; then
			backup_running_vm
		else
			echo KVM Virtualization is not installed on this machine.
		fi
		read -p "Press [Enter] key to return to the main menu: "
		clear
	;;
	3 )
		clear
		display_notice
		show_make_media_gui
		read -p "Press [Enter] key to return to the main menu: "
		clear
	;;
	esac
	done
}



show_view_informaion_about_this_system () {

	while true; do
		exec 3>&1
		selection=$($RTD_GUI \
		--backtitle "$BRANDING" \
		--title "System Information Menu" \
		--menu "" $HEIGHT $WIDTH $LIST_HEIGHT \
		"1" "Show system summary" \
		"2" "Show storage device space utilization" \
		"3" "Show users HOME folder storage use" \
		"4" "Show system temperature information" \
		"5" "Show detailed system CPU information" \
		"6" "Show systems physical location (city, county etc.)" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-

		case $exit_status in
		$DIALOG_CANCEL)
			echo "Returning to main menu..."
			show_main_menu
		;;
		$DIALOG_ESC)
			echo "Program aborted." >&2
			exit 1
		;;
		esac

		case $selection in
		0 )
		clear
		echo "Program terminated by user..."
		;;
		1 )
			clear
			check_dependencies neofetch
			clear
			neofetch --memory_display barinfo
			ip -br addr
			read -p "Press [Enter] key to return to the main menu: "
		;;
		2 )
			clear
			echo "Please wait while I calculate disk space... "
			result=$(df -h -x squashfs -x tmpfs)
			# Custom display of info, with scrollbar
			$RTD_GUI --backtitle "$BRANDING" --title "System Sorage Space" --msgbox --scrolltext "$result" 20 100
		;;
		3 )
			clear
			echo "Please wait while I calculate disk space... "
			result=$(du -sh /home/* 2> /dev/null)
			display_result "Home Space Utilization (All Users)"
		;;
		4 )
			check_dependencies lm-sensors
			sudo /etc/init.d/kmod start
			check_dependencies hddtemp
			sudo sensors-detect --auto
			clear
			result=$(sudo hddtemp /dev/sda; sensors )
			display_result "System Temperature Information"
		;;
		5 )
			clear
			result=$(lscpu)
			display_result "System CPU Information"
		;;
		6 )
			clear
			check_dependencies curl &>/dev/null
			check_dependencies dnsutils &>/dev/null
			result=$(curl ipinfo.io/`dig +short myip.opendns.com @resolver1.opendns.com`)
			display_result "This systems location on the Internet"
		;;
		esac
	done
}



show_manage_software_gui () {
	# List Options to be available for choice in the RTD System Configurator...
	while true; do
		exec 3>&1
		selection=$($RTD_GUI \
		--backtitle "$BRANDING" --title "Software Managment Menu"  --menu "" $HEIGHT $WIDTH $LIST_HEIGHT \
		"1" "Update all software on this system" \
		"2" "Show what Personal Package Archives (PPA's) are defined on this system" \
		"3" "Remove all Personal Package Archives (PPA's) NOT in use on this system" \
		"4" "Attempt a full release upgrade " \
		"5" "Install Non-GUI productivity tools for a useful terminal based workstation" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-

		case $exit_status in
		$DIALOG_CANCEL)
			echo "Returning to main menu..."
			show_main_menu
		;;
		$DIALOG_ESC)
			echo "Program aborted." >&2
			exit 1
		;;
		esac

		case $selection in
		0 )
			clear
			echo "Program terminated by user..."
		;;
		1 )
			clear
			rtd_update_system
			read -p "Press [Enter] key to return to the main menu: "
		;;
		2 )
			clear
			rtd_ppa_checker
			read -p "Press [Enter] key to let me know when you are done reading."
		;;
		3 )
			clear
			rtd_ppa_checker --delete
			read -p "Press [Enter] key to let me know when you are done reading."
		;;
		4 )
			clear
			if hash do-release-upgrade 2>/dev/null ; then
				do-release-upgrade
				read -p "Press [Enter] key to let me know when you are done reading."
			else
				read -p "This function requires the program "do-release-upgrade" (Ubuntu) on your system. Press [Enter] key to return to menu."
			fi
		;;
		5 )
			rtd_setup_choices_cli_workstation
		;;
		esac
	done
}



show_main_menu () {
	while true; do
		exec 3>&1
		# Dialog Display Menu Items...
			selection=$($RTD_GUI \
				--backtitle "$BRANDING" \
				--title "RTD Tool Main Menu" \
				--menu "" $HEIGHT $WIDTH $LIST_HEIGHT \
				"1" "View information about this system" \
				"2" "Manage Software on this system" \
				"3" "Manage KVM on this system" \
				"4" "Manage encryption phrases and passwords" \
				"5" "Shortcut: Make an automatic install ISO image (for VM's and CD burning)" \
				"6" "Shortcut: Update this system now"\
				2>&1 1>&3)
			exit_status=$?
			exec 3>&-

		# Cases for how program exited...
		case $exit_status in
			$DIALOG_CANCEL)
				clear
				echo "Program terminated."
				exit
			;;
			$DIALOG_ESC)
				clear
				echo "Program aborted." >&2
				exit 1
			;;
		esac

		# What to do depending on selection...
		case $selection in
			0 )
				clear
				echo "Program terminated."
			;;
			1 )
				show_view_informaion_about_this_system
			;;
			2 )
				show_manage_software_gui
			;;
			3 )
				show_manage_vm_gui
			;;
			4 )
				show_manage_crypt_sec
			;;
			5 )
				display_notice
				show_make_media_gui
				read -p "Press [Enter] key to return to the main menu: "
			;;
			6 )
				clear
				rtd_update_system
				read -p "Press [Enter] key to return to the main menu: "
			;;
		esac
	done
}



show_manage_crypt_sec () {
	while true; do
		exec 3>&1
		# Dialog Display Menu Items...
			selection=$($RTD_GUI \
				--backtitle "$BRANDING" \
				--title "Manage encryption phrases and passwords" \
				--menu "" $HEIGHT $WIDTH $LIST_HEIGHT \
				"1" "Check if a password is stolen" \
				"2" "Change systems disk encrytion pass phrase" \
				"3" "Change "$SUDO_USER" password" \
				2>&1 1>&3)
			exit_status=$?
			exec 3>&-

		# Cases for how program exited...
		case $exit_status in
			$DIALOG_CANCEL)
				clear
				echo "Program terminated."
				show_main_menu
			;;
			$DIALOG_ESC)
				clear
				echo "Program aborted." >&2
				exit 1
			;;
		esac

		# What to do depending on selection...
		case $selection in
			0 )
				clear
				echo "Program terminated."
			;;
			1 )
				check_if_password_p0wned
			;;
			2 )
				change_disk_pass
			;;
			3 )
				passwd $SUDO_USER
			;;
		esac
	done
}




#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::          Script templates                ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# Useful code sniplet templates. Copy and paste these and the edit them
# as necessary to extend the functoinality of this tool.
#




menu_template () {
	while true; do
		exec 3>&1
		# Dialog Display Menu Items...
			selection=$($RTD_GUI \
				--backtitle "$BRANDING" \
				--title "Menu Title" \
				--menu "Please tell me what I can do for you:" $HEIGHT $WIDTH $LIST_HEIGHT \
				"1" "Description" \
				"2" "Description" \
				"3" "Description" \
				2>&1 1>&3)
			exit_status=$?
			exec 3>&-

		# Cases for how program exited...
		case $exit_status in
			$DIALOG_CANCEL)
				clear
				echo "Program terminated."
				exit
			;;
			$DIALOG_ESC)
				clear
				echo "Program aborted." >&2
				exit 1
			;;
		esac

		# What to do depending on selection...
		case $selection in
			0 )
				clear
				echo "Program terminated."
			;;
			1 )
				# code
			;;
			2 )
				# code
			;;
			3 )
				# code
			;;
		esac
	done
}











#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::          Script Main Init                ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
# Below is the logic for starting this script. As this script pretty much exclusively uses
# functions and function calls for everything it is simple to control the flow of execution here.
# We must ensure that the script is run at the proper privileges and in a
# re-attachable session. This means that this script will not allow itself to be run in
# a root terminal or using the sudo command. The reason for this is that, in order to start in
# a detachable terminal session "byobu", it may not be launched by root. The script will
# need to be run as a normal administrative user with access to "sudo" a.k.a. a member of the
# "sudoers" security group. This helps adhere to the best practice of NOT using a root interactive
# terminal.

if [[ -z "${BASH_VERSINFO}" ]]; then
	echo "ERROR: You must execute this script in a BASH Shell" >&2
	exit 255
fi

if [[ "$RTD_GUI" == "dialog" ]]; then 
	if [[ -f ~/.dialogrc ]]; then 
		mv ~/.dialogrc ~/.dialogrc.rtd-bak 
		echo "screen_color = (WHITE,BLACK,OFF)" > ~/.dialogrc
	else 
		echo "screen_color = (WHITE,BLACK,OFF)" > ~/.dialogrc
	fi
fi 

if [[ "$TERM" == screen* ]]; then
	ensure_admin
	show_notice_on_fist_run
	check_dependencies $RTD_GUI
	show_main_menu
else
	if hash byobu 2>/dev/null; then
		byobu new-session -s "RTD Simple Server Support Tools" "$0 $@"
		#clear
	else
		check_dependencies byobu && echo -e $RED "A critical component needed for this script to work properly was attempted to be added... Attempting to run the script again!" $ENDCOLOR
		su -c "$0 $@" $SUDO_USER
		clear
	fi
fi

if [[ "$RTD_GUI" == "dialog" ]]; then 
	if [[ -f ~/.dialogrc.rtd-bak ]]; then 
		rm  ~/.dialogrc && mv ~/.dialogrc.rtd-bak ~/.dialogrc 
	fi
fi 
